# План миграции на микросервисы BrainMessenger

### 1. Введение

**Название проекта:** BrainMessenger

**Описание:** Документ описывает стратегию и этапы перехода BrainMessenger с монолитной архитектуры (NestJS) на микросервисную для повышения масштабируемости, отказоустойчивости и производительности.

**Цель:** Поддерживать 1 млн активных пользователей (NFR-4) с latency <500 мс (NFR-1) и упростить разработку новых функций (например, AI, боты).

**Текущий статус:** Монолит (v1.0, март 2025), переход запланирован на Q1 2026 (см. Дорожную карту).

---

### 2. Цели миграции

- **Масштабируемость:** Независимое масштабирование компонентов (чаты, звонки, AI).
- **Производительность:** Уменьшение зависимости между модулями, оптимизация нагрузки.
- **Гибкость:** Упрощение добавления функций (например, микросервис для AI-ассистента).
- **Отказоустойчивость:** Изоляция сбоев (ошибка в одном сервисе не ломает всё).

---

### 3. Текущая архитектура (Монолит)

- **Технологии:** NestJS, PostgreSQL (Neon), Cloudflare R2, Redis, Firebase.
- **Модули:**
  - Аутентификация (JWT, Gmail API).
  - Чаты (GraphQL, сообщения).
  - Звонки (WebRTC).
  - Уведомления (Firebase).
  - Платежи (Stripe).
  - AI (планируется в Q2 2026).
- **Проблемы:**
  - Единая точка отказа.
  - Сложность масштабирования под 1 млн пользователей.
  - Долгие циклы деплоя при росте кода.

---

### 4. Целевая архитектура (Микросервисы)

- **Принципы:**
  - Один сервис — одна ответственность.
  - Независимый деплой (Kubernetes).
  - Связь через API Gateway (GraphQL Federation).
- **Предложенные микросервисы:**

  | Сервис         | Ответственность         | Технологии          | База данных         |
  |----------------|-------------------------|---------------------|---------------------|
  | Auth           | Аутентификация, JWT     | NestJS, Neon        | PostgreSQL (Neon)   |
  | Chat           | Чаты, сообщения         | NestJS, Redis       | PostgreSQL (Neon)   |
  | Call           | Видео/аудиозвонки       | NestJS, WebRTC      | Redis               |
  | Notification   | Уведомления             | NestJS, Firebase    | -                   |
  | Payment        | Платежи, подписка       | NestJS, Stripe      | PostgreSQL (Neon)   |
  | AI             | Генерация ответов       | NestJS, Kafka       | Redis               |
  | API Gateway    | Маршрутизация, агрегация| Apollo Gateway      | -                   |

- **Схема:**

  ```
  [Client] → [API Gateway] → [Auth | Chat | Call | Notification | Payment | AI]
                     ↔ [Service Discovery (Consul)] ↔ [Message Broker (Kafka)]
                     ↔ [Monitoring (Prometheus/Grafana)] ↔ [Database (Neon/Cloudflare R2)]
  ```

---

### 5. Стратегия миграции

- **Подход:** Strangler Pattern (постепенная замена монолита).
  - Новые функции (AI, боты) сразу как микросервисы.
  - Существующие модули выносятся по одному.
- **Почему Strangler:**
  - Минимизация рисков (работающий монолит остаётся активным).
  - Постепенное обучение команды микросервисам.

---

### 6. Этапы миграции

#### 6.1. Подготовка (Q4 2025)

- **Длительность:** Октябрь-декабрь 2025.
- **Задачи:**
  1. Анализ монолита:
     - Идентификация границ модулей (Bounded Contexts).
     - Оценка зависимостей (например, Chat → Auth).
  2. Инфраструктура:
     - Настройка Kubernetes кластера (если не сделано).
     - Внедрение API Gateway (Apollo Federation).
     - Установка Kafka для асинхронной связи.
  3. Тестирование:
     - Создание staging-окружения для микросервисов.
     - Нагрузочное тестирование монолита (k6, 1000 пользователей).
- **Результат:** Готовность к первому сервису, документация зависимостей.

#### 6.2. Этап 1: Выделение Auth (Январь 2026)

- **Длительность:** 1 месяц.
- **Почему Auth:**
  - Независимый модуль с чёткими границами.
  - Используется всеми функциями (единая точка входа).
- **Шаги:**
  1. Создание микросервиса Auth:
     - Перенос логики JWT, Gmail API.
     - Эндпоинты: `/auth/login`, `/auth/refresh`.
  2. Интеграция через API Gateway:
     - Монолит перенаправляет запросы на Auth.
  3. Тестирование:
     - Проверка входа, выхода, 2FA.
  4. Деплой:
     - Rolling update в Kubernetes.
- **Результат:** Auth как отдельный сервис, монолит частично разгружен.

#### 6.3. Этап 2: Выделение Chat и Notification (Февраль 2026)

- **Длительность:** 1 месяц.
- **Почему:**
  - Основная нагрузка (сообщения, уведомления).
  - Высокая связность с Redis и Firebase.
- **Шаги:**
  1. Chat: Перенос GraphQL резолверов для чатов.
     - База: PostgreSQL (шард по `userId`) через Neon.
  2. Notification: Перенос логики Firebase.
     - Асинхронная отправка через Kafka.
  3. Интеграция: Связь через API Gateway и Kafka.
  4. Тестирование: Доставка сообщений <1 сек (NFR-3).
- **Результат:** Чаты и уведомления независимы, монолит уменьшен.

#### 6.4. Этап 3: Выделение Call и Payment (Март 2026)

- **Длительность:** 1 месяц.
- **Почему:**
  - Call: Высокая нагрузка на WebRTC.
  - Payment: Изоляция для безопасности (Stripe).
- **Шаги:**
  1. Call: Перенос WebRTC-сессий.
     - Кэш: Redis для состояния звонков.
  2. Payment: Перенос Stripe-интеграции.
     - База: Отдельная схема в PostgreSQL через Neon.
  3. Тестирование: Звонки до 50 участников, оплата подписки.
- **Результат:** Полная независимость ключевых функций.

#### 6.5. Завершение: AI и финализация (Апрель 2026)

- **Длительность:** 1 месяц (совмещено с Q2 2026).
- **Шаги:**
  1. AI: Развёртывание как микросервис (см. Спецификацию AI-интеграций).
  2. Отключение монолита:
     - Перенос остатков (например, health-эндпоинт).
  3. Оптимизация: Балансировка нагрузки через API Gateway.
- **Результат:** Полный переход на микросервисы.

---

### 7. Техническая реализация

#### 7.1. API Gateway

- **Apollo Federation:**
  ```graphql
  type Query @extends {
    user(id: ID!): User @provides(fields: "id") @external
  }
  ```
- **Конфигурация:**
  ```yaml
  services:
    - name: auth
      url: http://auth-service:3000/graphql
    - name: chat
      url: http://chat-service:3000/graphql
  ```

#### 7.2. Связь между сервисами

- **Синхронная:** GraphQL через API Gateway.
- **Асинхронная:** Kafka для событий (например, `message.sent` → Notification).
  ```typescript
  @KafkaProducer()
  async sendMessageEvent(message: Message) {
    await this.kafka.emit('message.sent', message)
  }
  ```

#### 7.3. Мониторинг

- Метрики для каждого сервиса в Prometheus (см. Руководство по мониторингу).
- Service Discovery через Consul.

---

### 8. Риски и их минимизация

| Риск               | Вероятность | Последствия           | Решение                          |
|--------------------|-------------|-----------------------|----------------------------------|
| Ошибки интеграции  | Средняя     | Сбой функций          | Тестирование в staging           |
| Увеличение latency | Низкая      | >500 мс               | Оптимизация через Redis/Kafka    |
| Потеря данных      | Низкая      | Удаление сообщений    | Бэкапы перед миграцией (Neon)    |
| Сложность отладки  | Высокая     | Долгий поиск багов    | Логи в ELK, трассировка (Sentry) |

---

### 9. Тестирование

- **Сценарии:**
  - 1000 одновременных пользователей на каждом сервисе.
  - Ошибка в одном сервисе (Chat) не ломает другие.
  - Миграция данных без потерь.
- **Инструменты:** k6, Cypress, PostgreSQL pg_dump.

---

### 10. Примечания

- **График:** Q4 2025 — подготовка, Q1 2026 — реализация.
- **Ресурсы:** Добавить 2 разработчиков для Kafka и Federation.
- **Реверс:** Монолит остаётся доступным до полной стабилизации.